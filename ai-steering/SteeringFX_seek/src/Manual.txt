
1. Все steering-методы вычисляют желаемый вектор скорости: нормализованный вектор, длина которого пропорциональна величине скорости,
а направление вектора указывает направление скорости.

2. SteeringBehavior::calculateForce() расчитывает вектор силы, требуемый для изменения скорости 
согласно полученному вектору желаемой скорости из steering-методов.

3. Vehicle::update() по вектору силы расчитывает величину фактической скорости и новое положение агента.

4. Vehicle::getTransformVehicle() возвращает трансформированный список вершин агента.
С помощью Transformation::worldTransform() расчитывается трансфрмация изображения агента в соответствии с
направлением движения агента, его положением и масштабом (rotate, translation and scalе).




Алгоритм:
1. Запуск таймера в Main::start() timer.start()

2. Таймер циклически вызывает свой метод handle(), который каждый такт :
 - очищает канвас: cgdi.clear();
 - рендерит фигуры агентов: gameWorld.render();
 - обновляет положение агентов:  gameWorld.update();

3.  gameWorld.update(); вызывает метод каждого агента Vehicle::update(), который:
    - по вектору силы расчитывает величину фактической скорости и новое положение агента.
    Вектор силы находится методом SteeringBehavior::calculateForce()

4. SteeringBehavior::calculateForce() вызывает один из методов вычисления силы в зависимости от предустановок:
    - calculatePrioritized(): 
        - вычисляет добавочную силу для приоритетного поведения
        SteeringBehavior::accumulateForce(Vector2D plusForce):    
        - проверяет не превысила ли действующая сила максимальную величину
        - если не превысила, то к действующей силе добавляется добавочная так, чтобы сумма не превысила максимальную величину
        Сложность заключатся в определении приоритетеного поведения.
- calculateWeightedSum():
        - вычисляет добавочные силы всех поведений и добавляет их к действующей силе
        - превышение общей суммы обрезается до максимальную величины (steeringForce.truncate(vehicle.getMaxForce());)
        Получается усреднённая сумма сил набора поведений. Применяется, когда сложно определить одно приоритетное поведение.
    - calculateDithered():
        - вычисляет добавочную силу только в тот такт цикла, когда вероятность наступила. Превышение максимума или ниже нуля обрезаются.
        Т.е. вычисление силы производится не каждый такт, а с пропусками. Это повышает производительность,
        но снижает точность, поэтому такое вычисление применяется для второстепенных агентов.
    Для нашей программы выбрано по умолчанию calculatePrioritized(). 

    Все эти методы для расчёта силы используют поведенческий вектор прибавочной скорости, умноженный на weight-множитель поведения:
    steeringForce = steeringVelocity * weightBehavior

5. Для расчета силы вызываются поведенческие методы, которые возвращают прибавочный вектор скорости.
    В нашей программе вызов поведенческие метода производится с помощью метод on(BehaviorType bt).
    В конструкторе GameWorld принудительно назначается всем агентам vehicle.getSteering().flockingOn(),
    а большому агенту wanderOn().
    В реальной программе выбор поведения должен осуществляться в зависимости от условий программы.
